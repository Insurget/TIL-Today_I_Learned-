# 1. 프로시저를 써서 요약하는 방법
## 1.1 프로그램 짤 때 바탕이 되는 것
### 좋은 프로그래밍 언어가 가지고 있는 세 가지 표현 방식
- 기본식<sup>primitive expression</sup> : 언어에서 가장 단순한 것을 나타낸다.
- 엮어내는 수단<sup>means of combination</sup> : 간단한 것을 모아 복잡한 것<sup>compound element</sup>으로 만든다.
- 요약하는 수단<sup>means of abstraction</sup> : 복잡한 것에 이름을 붙여 하나로 다룰 수 있게 끔 간추린다.
### 1.1.1 식
- 우리가 **식**<sup>**expression**</sup>을 쳐 놓으면, 실행기는 그 식을 **셈**<sup>계산, evaluation</sup>하여 값을 찍는다.
> example)
> ``` Lisp
> 486
> ```
> output : 486
- 수를 나타낸 식, 기본 프로시저를 나타내는 식, +나 * 같은 기호를 한데 엮어 좀 더 복잡한 식<sup>compound expression</sup>을 적을 수 있다.
> example)
> ``` Lisp
> (+ 137 349)
> (- 1000 334)
> (* 5 99)
> (/ 10 5)
> (+ 2.7  10)
> ```
> output : <br>486<br>666<br>95<br>2<br>12.7

- 위 같이 여러 식을 괄호로 묶어 리스트를 만들고 프로시저 적용<sup>procedure application</sup>을 뜻하도록 엮어 놓은 식은 **엮은식**<sup>**combination**</sup>이라고 한다.
- 맨 왼쪽에 있는 식은 **연산자**<sup>operater</sup>
- 나머지 식은 **피연산자**<sup>operand</sup>
- 엮은식을 계산한 값은, **인자**<sup>argument</sup>에 프로시저를 적용하여 얻는다.
- **앞가지 쓰기**<sup>prefix</sup> : 연산자를 피연산자 왼쪽에 두는 방식
> 앞가지 쓰기의 좋은 점
> 1. 인자가 많아져도 따로 문법을 만들 필요 없이 쓰던 그대로 쓸 수 있다는 점이다.
>> ex)
> > ```lisp
> > (+ 21  35 12 7)
> > ```
> > output : 75
> 2. **식** 속에 다시 **식**을 넣어서 식을 여러 겹으로 엮어 늘리기가 쉽다는 점이다.
> > ex)
> > ```lisp
> > (+ (* 3 5) (- 10 6))
> > ```
> > output : 19

- **가지런히 쓰기**<sup>예쁘게 쓰기, pretty-printing</sup> : 식을 깊이 겹쳐 써야 할 때 인자를 중심으로 줄을 맞추고 알맞게 들여 쓰는 방식
___
### 1.1.2 이름과 환경
#### 이름
  프로그래밍 언어에서 아주 중요한 기능 가운데 하나는 계산 물체<sup>computational object</sup>에 이름을 붙이는 수단이다. 이때 이름은 **변수**<sup>variable</sup>가 되고, 그 변수의 **값**<sup>value</sup>은 계산 물체가 된다.
  - Scheme에서는 이름을 지을 때 **define**을 쓴다.

```Lisp
(define size 2)
```
위 식을 실행기에 건네면, 실행기는 2라는 값에 size라는 이름을 붙인다.

한번 **size**라는 이름의 값을 2로 정하면, size라는 이름만으로 2라는 값을 나타낼 수 있다.
```Lisp
size
(* 5 size)
```
output : <br>2<br>10
#### 환경
실행기 속 어딘가에 이름-물체<sup>name-object</sup>의 쌍을 저장해 둔 메모리<sup>memory</sup>가 있는데, 이런 기억 공간을 **환경**<sup>environment</sup>이라고 한다.

### 1.1.3 엮은식<sup>combination</sup>을 계산하는 방법
![나무꼴 어큐뮬레이션](https://github.com/Insurget/TIL-Today_I_Learned-/blob/master/Structure%20and%20Interpretation%20of%20Computer%20Programs/1.%20%ED%94%84%EB%A1%9C%EC%8B%9C%EC%A0%80%EB%A5%BC%20%EC%8D%A8%EC%84%9C%20%EC%9A%94%EC%95%BD%ED%95%98%EB%8A%94%20%EB%B0%A9%EB%B2%95/tree%20accumulation.JPG?raw=true "tree accumulation")
```Lisp
(* (+ 2 (* 4 6)) (+ 3 5 7))
```
- 나무 그림 속에서 연산자는 **마디**<sup>**node**</sup>로, 연산할 것들은 **가지**<sup>**branch**</sup>로 나타내며, 끝 마디<sup>가지가 끝나는 마디, terminal node</sup>에는 연산자나 수가 달려 있다.
- 계산프로세스를 나무에 빗대어 보면, 피연산자의 값들이 끝 마디부터 가지를 타고 하나씩 더 높은 단계로 올라가며 엮이는 셈이다. 이렇게 같은 절차를 여러 번 되밟는 기법, 줄여서 **되돌기**<sup>**재귀, recursion**</sup>는, 나무 같은 계층 구조 물체(데이터)를 다루기에 알맞은 기법이다.
- 값을 위로 올려 보내는 규칙은 **나무꼴 어큘레이션**<sup>tree accumulation</sup>이라 하는 계산 방법의 한 가지다.

### 1.1.4 묶음 프로시저<sup>compound procedure</sup>
- **프로시저 정의**<sup>procedure definition</sup> : 복잡한 연산<sup>compound operation</sup>에 이름을 붙여서 쓰는 방법, 큰 프로그램을 짤 적에 아주 쓸모가 많다.
<pre>
(define    (square    x)    (*          x       x))
  ▲           ▲       ▲      ▲          ▲       ▲
  To      square  something, multiply  it by itself.
  </pre>
  
  ▲ 제곱
 > -  이미 있던 프로시저를 하나로 묶어서 만든 프로시저, 곧 square라 이름 붙은 '묶음 프로시저<sup>compound procedure</sup>'가 하나 생긴다.
>  -  곱할 값을 x라는 같힌 이름<sup>local name</sup>으로 받아오는데, 이는 마치 자연어에서 대명사와 쓰임새가 비슷하다.

```lScheme
(define (<name> <formal parameters>) <body>)
```
- <xmp><name> : 환</xmp>